var ot_es =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack://ot_es/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://ot_es/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://ot_es/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://ot_es/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ot_es/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://ot_es/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/browser/ajax-adapter.js":
/*!*************************************!*\
  !*** ./src/browser/ajax-adapter.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AjaxAdapter; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AjaxAdapter =\n/*#__PURE__*/\nfunction () {\n  function AjaxAdapter(path, ownUserName, revision) {\n    _classCallCheck(this, AjaxAdapter);\n\n    if (path[path.length - 1] !== '/') {\n      path += '/';\n    }\n\n    this.path = path;\n    this.ownUserName = ownUserName;\n    this.majorRevision = revision.major || 0;\n    this.minorRevision = revision.minor || 0;\n    this.poll();\n  }\n\n  _createClass(AjaxAdapter, [{\n    key: \"renderRevisionPath\",\n    value: function renderRevisionPath() {\n      return 'revision/' + this.majorRevision + '-' + this.minorRevision;\n    }\n  }, {\n    key: \"handleResponse\",\n    value: function handleResponse(data) {\n      var i;\n      var operations = data.operations;\n\n      for (i = 0; i < operations.length; i++) {\n        if (operations[i].user === this.ownUserName) {\n          this.trigger('ack');\n        } else {\n          this.trigger('operation', operations[i].operation);\n        }\n      }\n\n      if (operations.length > 0) {\n        this.majorRevision += operations.length;\n        this.minorRevision = 0;\n      }\n\n      var events = data.events;\n\n      if (events) {\n        for (i = 0; i < events.length; i++) {\n          var user = events[i].user;\n\n          if (user === this.ownUserName) {\n            continue;\n          }\n\n          switch (events[i].event) {\n            case 'joined':\n              this.trigger('set_name', user, user);\n              break;\n\n            case 'left':\n              this.trigger('client_left', user);\n              break;\n\n            case 'selection':\n              this.trigger('selection', user, events[i].selection);\n              break;\n          }\n        }\n\n        this.minorRevision += events.length;\n      }\n\n      var users = data.users;\n\n      if (users) {\n        delete users[this.ownUserName];\n        this.trigger('clients', users);\n      }\n\n      if (data.revision) {\n        this.majorRevision = data.revision.major;\n        this.minorRevision = data.revision.minor;\n      }\n    }\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      var self = this;\n      $.ajax({\n        url: this.path + this.renderRevisionPath(),\n        type: 'GET',\n        dataType: 'json',\n        timeout: 5000,\n        success: function success(data) {\n          self.handleResponse(data);\n          self.poll();\n        },\n        error: function error() {\n          setTimeout(function () {\n            self.poll();\n          }, 500);\n        }\n      });\n    }\n  }, {\n    key: \"sendOperation\",\n    value: function sendOperation(revision, operation, selection) {\n      if (revision !== this.majorRevision) {\n        throw new Error(\"Revision numbers out of sync\");\n      }\n\n      var self = this;\n      $.ajax({\n        url: this.path + this.renderRevisionPath(),\n        type: 'POST',\n        data: JSON.stringify({\n          operation: operation,\n          selection: selection\n        }),\n        contentType: 'application/json',\n        processData: false,\n        success: function success(data) {},\n        error: function error() {\n          setTimeout(function () {\n            self.sendOperation(revision, operation, selection);\n          }, 500);\n        }\n      });\n    }\n  }, {\n    key: \"sendSelection\",\n    value: function sendSelection(obj) {\n      $.ajax({\n        url: this.path + this.renderRevisionPath() + '/selection',\n        type: 'POST',\n        data: JSON.stringify(obj),\n        contentType: 'application/json',\n        processData: false,\n        timeout: 1000\n      });\n    }\n  }, {\n    key: \"registerCallbacks\",\n    value: function registerCallbacks(cb) {\n      this.callbacks = cb;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var action = this.callbacks && this.callbacks[event];\n\n      if (action) {\n        action.apply(this, args);\n      }\n    }\n  }]);\n\n  return AjaxAdapter;\n}();\n\n\n\n//# sourceURL=webpack://ot_es/./src/browser/ajax-adapter.js?");

/***/ }),

/***/ "./src/browser/client.js":
/*!*******************************!*\
  !*** ./src/browser/client.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Client; });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AwaitingConfirm =\n/*#__PURE__*/\nfunction () {\n  // In the 'AwaitingConfirm' state, there's one operation the client has sent\n  // to the server and is still waiting for an acknowledgement.\n  function AwaitingConfirm(outstanding) {\n    _classCallCheck(this, AwaitingConfirm);\n\n    // Save the pending operation\n    this.outstanding = outstanding;\n  }\n\n  _createClass(AwaitingConfirm, [{\n    key: \"applyClient\",\n    value: function applyClient(client, operation) {\n      // When the user makes an edit, don't send the operation immediately,\n      // instead switch to 'AwaitingWithBuffer' state\n      return new AwaitingWithBuffer(this.outstanding, operation);\n    }\n  }, {\n    key: \"applyServer\",\n    value: function applyServer(client, revision, operation) {\n      if (revision - client.revision > 1) {\n        throw new Error(\"Invalid revision.\");\n      }\n\n      client.revision = revision; // This is another client's operation. Visualization:\n      //\n      //                   /\\\n      // this.outstanding /  \\ operation\n      //                 /    \\\n      //                 \\    /\n      //  pair[1]         \\  / pair[0] (new outstanding)\n      //  (can be applied  \\/\n      //  to the client's\n      //  current document)\n\n      var pair = operation.constructor.transform(this.outstanding, operation);\n      client.applyOperation(pair[1]);\n      return new AwaitingConfirm(pair[0]);\n    }\n  }, {\n    key: \"serverAck\",\n    value: function serverAck(client, revision) {\n      if (revision - client.revision > 1) {\n        return new Stale(this.outstanding, client, revision).getOperations();\n      }\n\n      client.revision = revision; // The client's operation has been acknowledged\n      // => switch to synchronized state\n\n      return synchronized_;\n    }\n  }, {\n    key: \"transformSelection\",\n    value: function transformSelection(selection) {\n      return selection.transform(this.outstanding);\n    }\n  }, {\n    key: \"resend\",\n    value: function resend(client) {\n      // The confirm didn't come because the client was disconnected.\n      // Now that it has reconnected, we resend the outstanding operation.\n      client.sendOperation(client.revision, this.outstanding);\n    }\n  }]);\n\n  return AwaitingConfirm;\n}();\n\nvar Synchronized =\n/*#__PURE__*/\nfunction () {\n  function Synchronized() {\n    _classCallCheck(this, Synchronized);\n  }\n\n  _createClass(Synchronized, [{\n    key: \"applyClient\",\n    value: function applyClient(client, operation) {\n      // When the user makes an edit, send the operation to the server and\n      // switch to the 'AwaitingConfirm' state\n      client.sendOperation(client.revision, operation);\n      return new AwaitingConfirm(operation);\n    }\n  }, {\n    key: \"applyServer\",\n    value: function applyServer(client, revision, operation) {\n      if (revision - client.revision > 1) {\n        throw new Error(\"Invalid revision.\");\n      }\n\n      client.revision = revision; // When we receive a new operation from the server, the operation can be\n      // simply applied to the current document\n\n      client.applyOperation(operation);\n      return this;\n    }\n  }, {\n    key: \"serverAck\",\n    value: function serverAck(client, revision) {\n      throw new Error(\"There is no pending operation.\");\n    }\n  }, {\n    key: \"transformSelection\",\n    // Nothing to do because the latest server state and client state are the same.\n    value: function transformSelection(x) {\n      return x;\n    }\n  }]);\n\n  return Synchronized;\n}();\n/*\n * XXX: Singleton ????\n */\n\n\nvar synchronized_ = new Synchronized();\n\nvar StaleWithBuffer =\n/*#__PURE__*/\nfunction () {\n  function StaleWithBuffer(acknowlaged, buffer, client, revision) {\n    _classCallCheck(this, StaleWithBuffer);\n\n    this.acknowlaged = acknowlaged;\n    this.buffer = buffer;\n    this.client = client;\n    this.revision = revision;\n  }\n\n  _createClass(StaleWithBuffer, [{\n    key: \"applyClient\",\n    value: function applyClient(client, operation) {\n      var buffer = this.buffer.compose(operation);\n      return new StaleWithBuffer(this.acknowlaged, buffer, client, this.revision);\n    }\n  }, {\n    key: \"applyServer\",\n    value: function applyServer(client, revision, operation) {\n      throw new Error(\"Ignored server-side change.\");\n    }\n  }, {\n    key: \"applyOperations\",\n    value: function applyOperations(client, head, operations) {\n      var transform = this.acknowlaged.constructor.transform;\n\n      for (var i = 0; i < operations.length; i++) {\n        var op = ot.TextOperation.fromJSON(operations[i]);\n        var pair1 = transform(this.acknowlaged, op);\n        var pair2 = transform(this.buffer, pair1[1]);\n        client.applyOperation(pair2[1]);\n        this.acknowlaged = pair1[0];\n        this.buffer = pair2[0];\n      }\n\n      client.revision = this.revision;\n      client.sendOperation(client.revision, this.buffer);\n      return new AwaitingConfirm(this.buffer);\n    }\n  }, {\n    key: \"serverAck\",\n    value: function serverAck(client, revision) {\n      throw new Error(\"There is no pending operation.\");\n    }\n  }, {\n    key: \"transformSelection\",\n    value: function transformSelection(selection) {\n      return selection;\n    }\n  }, {\n    key: \"getOperations\",\n    value: function getOperations() {\n      this.client.getOperations(this.client.revision, this.revision - 1); // acknowlaged is the one at revision\n\n      return this;\n    }\n  }]);\n\n  return StaleWithBuffer;\n}();\n\nvar Stale =\n/*#__PURE__*/\nfunction () {\n  function Stale(acknowlaged, client, revision) {\n    _classCallCheck(this, Stale);\n\n    this.acknowlaged = acknowlaged;\n    this.client = client;\n    this.revision = revision;\n  }\n\n  _createClass(Stale, [{\n    key: \"applyClient\",\n    value: function applyClient(client, operation) {\n      return new StaleWithBuffer(this.acknowlaged, operation, client, this.revision);\n    }\n  }, {\n    key: \"applyServer\",\n    value: function applyServer(client, revision, operation) {\n      throw new Error(\"Ignored server-side change.\");\n    }\n  }, {\n    key: \"applyOperations\",\n    value: function applyOperations(client, head, operations) {\n      var transform = this.acknowlaged.constructor.transform;\n\n      for (var i = 0; i < operations.length; i++) {\n        var op = ot.TextOperation.fromJSON(operations[i]);\n        var pair = transform(this.acknowlaged, op);\n        client.applyOperation(pair[1]);\n        this.acknowlaged = pair[0];\n      }\n\n      client.revision = this.revision;\n      return synchronized_;\n    }\n  }, {\n    key: \"serverAck\",\n    value: function serverAck(client, revision) {\n      throw new Error(\"There is no pending operation.\");\n    }\n  }, {\n    key: \"transformSelection\",\n    value: function transformSelection(selection) {\n      return selection;\n    }\n  }, {\n    key: \"getOperations\",\n    value: function getOperations() {\n      this.client.getOperations(this.client.revision, this.revision - 1); // acknowlaged is the one at revision\n\n      return this;\n    }\n  }]);\n\n  return Stale;\n}();\n\nvar AwaitingWithBuffer =\n/*#__PURE__*/\nfunction () {\n  // In the 'AwaitingWithBuffer' state, the client is waiting for an operation\n  // to be acknowledged by the server while buffering the edits the user makes\n  function AwaitingWithBuffer(outstanding, buffer) {\n    _classCallCheck(this, AwaitingWithBuffer);\n\n    // Save the pending operation and the user's edits since then\n    this.outstanding = outstanding;\n    this.buffer = buffer;\n  }\n\n  _createClass(AwaitingWithBuffer, [{\n    key: \"applyClient\",\n    value: function applyClient(client, operation) {\n      // Compose the user's changes onto the buffer\n      var newBuffer = this.buffer.compose(operation);\n      return new AwaitingWithBuffer(this.outstanding, newBuffer);\n    }\n  }, {\n    key: \"applyServer\",\n    value: function applyServer(client, revision, operation) {\n      if (revision - client.revision > 1) {\n        throw new Error(\"Invalid revision.\");\n      }\n\n      client.revision = revision; // Operation comes from another client\n      //\n      //                       /\\\n      //     this.outstanding /  \\ operation\n      //                     /    \\\n      //                    /\\    /\n      //       this.buffer /  \\* / pair1[0] (new outstanding)\n      //                  /    \\/\n      //                  \\    /\n      //          pair2[1] \\  / pair2[0] (new buffer)\n      // the transformed    \\/\n      // operation -- can\n      // be applied to the\n      // client's current\n      // document\n      //\n      // * pair1[1]\n\n      var transform = operation.constructor.transform;\n      var pair1 = transform(this.outstanding, operation);\n      var pair2 = transform(this.buffer, pair1[1]);\n      client.applyOperation(pair2[1]);\n      return new AwaitingWithBuffer(pair1[0], pair2[0]);\n    }\n  }, {\n    key: \"serverAck\",\n    value: function serverAck(client, revision) {\n      if (revision - client.revision > 1) {\n        return new StaleWithBuffer(this.outstanding, this.buffer, client, revision).getOperations();\n      }\n\n      client.revision = revision; // The pending operation has been acknowledged\n      // => send buffer\n\n      client.sendOperation(client.revision, this.buffer);\n      return new AwaitingConfirm(this.buffer);\n    }\n  }, {\n    key: \"transformSelection\",\n    value: function transformSelection(selection) {\n      return selection.transform(this.outstanding).transform(this.buffer);\n    }\n  }, {\n    key: \"resend\",\n    value: function resend(client) {\n      // The confirm didn't come because the client was disconnected.\n      // Now that it has reconnected, we resend the outstanding operation.\n      client.sendOperation(client.revision, this.outstanding);\n    }\n  }]);\n\n  return AwaitingWithBuffer;\n}();\n\nvar Client =\n/*#__PURE__*/\nfunction () {\n  function Client(revision) {\n    _classCallCheck(this, Client);\n\n    this.revision = revision; // the next expected revision number\n\n    this.setState(synchronized_); // start state\n  }\n\n  _createClass(Client, [{\n    key: \"setState\",\n    value: function setState(state) {\n      this.state = state;\n    }\n  }, {\n    key: \"applyClient\",\n    // Call this method when the user changes the document.\n    value: function applyClient(operation) {\n      this.setState(this.state.applyClient(this, operation));\n    }\n  }, {\n    key: \"applyServer\",\n    // Call this method with a new operation from the server\n    value: function applyServer(revision, operation) {\n      this.setState(this.state.applyServer(this, revision, operation));\n    }\n  }, {\n    key: \"applyOperations\",\n    value: function applyOperations(head, operations) {\n      this.setState(this.state.applyOperations(this, head, operations));\n    }\n  }, {\n    key: \"serverAck\",\n    value: function serverAck(revision) {\n      this.setState(this.state.serverAck(this, revision));\n    }\n  }, {\n    key: \"serverReconnect\",\n    value: function serverReconnect() {\n      if (typeof this.state.resend === 'function') {\n        this.state.resend(this);\n      }\n    }\n  }, {\n    key: \"transformSelection\",\n    // Transforms a selection from the latest known server state to the current\n    // client state. For example, if we get from the server the information that\n    // another user's cursor is at position 3, but the server hasn't yet received\n    // our newest operation, an insertion of 5 characters at the beginning of the\n    // document, the correct position of the other user's cursor in our current\n    // document is 8.\n    value: function transformSelection(selection) {\n      return this.state.transformSelection(selection);\n    }\n  }, {\n    key: \"sendOperation\",\n    // Override this method.\n    value: function sendOperation(revision, operation) {\n      throw new Error(\"sendOperation must be defined in child class\");\n    }\n  }, {\n    key: \"applyOperation\",\n    // Override this method.\n    value: function applyOperation(operation) {\n      throw new Error(\"applyOperation must be defined in child class\");\n    }\n  }]);\n\n  return Client;\n}();\n\n_defineProperty(Client, \"Synchronized\", Synchronized);\n\n_defineProperty(Client, \"AwaitingConfirm\", AwaitingConfirm);\n\n_defineProperty(Client, \"AwaitingWithBuffer\", AwaitingWithBuffer);\n\n\n\n//# sourceURL=webpack://ot_es/./src/browser/client.js?");

/***/ }),

/***/ "./src/browser/codemirror-adapter.js":
/*!*******************************************!*\
  !*** ./src/browser/codemirror-adapter.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CodeMirrorAdapter; });\n/* harmony import */ var common_text_operation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/text-operation */ \"./src/common/text-operation.js\");\n/* harmony import */ var common_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/selection */ \"./src/common/selection.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar cmpPos = function cmpPos(a, b) {\n  if (a.line < b.line) {\n    return -1;\n  }\n\n  if (a.line > b.line) {\n    return 1;\n  }\n\n  if (a.ch < b.ch) {\n    return -1;\n  }\n\n  if (a.ch > b.ch) {\n    return 1;\n  }\n\n  return 0;\n};\n\nvar posEq = function posEq(a, b) {\n  return mpPos(a, b) === 0;\n};\n\nvar posLe = function posLe(a, b) {\n  return cmpPos(a, b) <= 0;\n};\n\nvar minPos = function minPos(a, b) {\n  return posLe(a, b) ? a : b;\n};\n\nvar maxPos = function maxPos(a, b) {\n  return posLe(a, b) ? b : a;\n};\n\nvar codemirrorDocLength = function codemirrorDocLength(doc) {\n  return doc.indexFromPos({\n    line: doc.lastLine(),\n    ch: 0\n  }) + doc.getLine(doc.lastLine()).length;\n};\n\nvar operationFromCodeMirrorChanges = function operationFromCodeMirrorChanges(changes, doc) {\n  // Approach: Replay the changes, beginning with the most recent one, and\n  // construct the operation and its inverse. We have to convert the position\n  // in the pre-change coordinate system to an index. We have a method to\n  // convert a position in the coordinate system after all changes to an index,\n  // namely CodeMirror's `indexFromPos` method. We can use the information of\n  // a single change object to convert a post-change coordinate system to a\n  // pre-change coordinate system. We can now proceed inductively to get a\n  // pre-change coordinate system for all changes in the linked list.\n  // A disadvantage of this approach is its complexity `O(n^2)` in the length\n  // of the linked list of changes.\n  var docEndLength = codemirrorDocLength(doc);\n  var operation = new common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().retain(docEndLength);\n  var inverse = new common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().retain(docEndLength);\n\n  var indexFromPos = function indexFromPos(pos) {\n    return doc.indexFromPos(pos);\n  };\n\n  function last(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function sumLengths(strArr) {\n    if (strArr.length === 0) {\n      return 0;\n    }\n\n    var sum = 0;\n\n    for (var i = 0; i < strArr.length; i++) {\n      sum += strArr[i].length;\n    }\n\n    return sum + strArr.length - 1;\n  }\n\n  function updateIndexFromPos(indexFromPos, change) {\n    return function (pos) {\n      if (posLe(pos, change.from)) {\n        return indexFromPos(pos);\n      }\n\n      if (posLe(change.to, pos)) {\n        return indexFromPos({\n          line: pos.line + change.text.length - 1 - (change.to.line - change.from.line),\n          ch: change.to.line < pos.line ? pos.ch : change.text.length <= 1 ? pos.ch - (change.to.ch - change.from.ch) + sumLengths(change.text) : pos.ch - change.to.ch + last(change.text).length\n        }) + sumLengths(change.removed) - sumLengths(change.text);\n      }\n\n      if (change.from.line === pos.line) {\n        return indexFromPos(change.from) + pos.ch - change.from.ch;\n      }\n\n      return indexFromPos(change.from) + sumLengths(change.removed.slice(0, pos.line - change.from.line)) + 1 + pos.ch;\n    };\n  }\n\n  for (var i = changes.length - 1; i >= 0; i--) {\n    var change = changes[i];\n    indexFromPos = updateIndexFromPos(indexFromPos, change);\n    var fromIndex = indexFromPos(change.from);\n    var restLength = docEndLength - fromIndex - sumLengths(change.text);\n    operation = new common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().retain(fromIndex)['delete'](sumLengths(change.removed)).insert(change.text.join('\\n')).retain(restLength).compose(operation);\n    inverse = inverse.compose(new common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().retain(fromIndex)['delete'](sumLengths(change.text)).insert(change.removed.join('\\n')).retain(restLength));\n    docEndLength += sumLengths(change.removed) - sumLengths(change.text);\n  }\n\n  return [operation, inverse];\n};\n\nvar CodeMirrorAdapter =\n/*#__PURE__*/\nfunction () {\n  function CodeMirrorAdapter(cm) {\n    _classCallCheck(this, CodeMirrorAdapter);\n\n    this.cm = cm;\n    this.ignoreNextChange = false;\n    this.changeInProgress = false;\n    this.selectionChanged = false; // use addStyleRule\n\n    this.addedStyle = {};\n    this.styleElement = document.createElement('style');\n    document.documentElement.getElementsByTagName('head')[0].appendChild(this.styleElement);\n    this.styleSheet = this.styleElement.sheet;\n\n    this._bind(this, 'onChanges');\n\n    this._bind(this, 'onChange');\n\n    this._bind(this, 'onCursorActivity');\n\n    this._bind(this, 'onFocus');\n\n    this._bind(this, 'onBlur');\n\n    cm.on('changes', this.onChanges);\n    cm.on('change', this.onChange);\n    cm.on('cursorActivity', this.onCursorActivity);\n    cm.on('focus', this.onFocus);\n    cm.on('blur', this.onBlur);\n  } // Removes all event listeners from the CodeMirror instance.\n\n\n  _createClass(CodeMirrorAdapter, [{\n    key: \"detach\",\n    value: function detach() {\n      this.cm.off('changes', this.onChanges);\n      this.cm.off('change', this.onChange);\n      this.cm.off('cursorActivity', this.onCursorActivity);\n      this.cm.off('focus', this.onFocus);\n      this.cm.off('blur', this.onBlur);\n    }\n  }, {\n    key: \"registerCallbacks\",\n    value: function registerCallbacks(cb) {\n      this.callbacks = cb;\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange() {\n      // By default, CodeMirror's event order is the following:\n      // 1. 'change', 2. 'cursorActivity', 3. 'changes'.\n      // We want to fire the 'selectionChange' event after the 'change' event,\n      // but need the information from the 'changes' event. Therefore, we detect\n      // when a change is in progress by listening to the change event, setting\n      // a flag that makes this adapter defer all 'cursorActivity' events.\n      this.changeInProgress = true;\n    }\n  }, {\n    key: \"onChanges\",\n    value: function onChanges(_, changes) {\n      if (!this.ignoreNextChange) {\n        var pair = CodeMirrorAdapter.operationFromCodeMirrorChanges(changes, this.cm);\n        this.trigger('change', pair[0], pair[1]);\n      }\n\n      if (this.selectionChanged) {\n        this.trigger('selectionChange');\n      }\n\n      this.changeInProgress = false;\n      this.ignoreNextChange = false;\n    }\n  }, {\n    key: \"onFocus\",\n    value: function onFocus() {\n      if (this.changeInProgress) {\n        this.selectionChanged = true;\n      } else {\n        this.trigger('selectionChange');\n      }\n    }\n  }, {\n    key: \"onCursorActivity\",\n    value: function onCursorActivity() {\n      if (this.changeInProgress) {\n        this.selectionChanged = true;\n      } else {\n        this.trigger('selectionChange');\n      }\n    }\n  }, {\n    key: \"onBlur\",\n    value: function onBlur() {\n      if (!this.cm.somethingSelected()) {\n        this.trigger('blur');\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.cm.getValue();\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      var cm = this.cm;\n      var selectionList = cm.listSelections();\n      var ranges = [];\n\n      for (var i = 0; i < selectionList.length; i++) {\n        ranges[i] = new common_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Range(cm.indexFromPos(selectionList[i].anchor), cm.indexFromPos(selectionList[i].head));\n      }\n\n      return new common_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"](ranges);\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      var ranges = [];\n\n      for (var i = 0; selection && i < selection.ranges.length; i++) {\n        var range = selection.ranges[i];\n        ranges[i] = {\n          anchor: this.cm.posFromIndex(range.anchor),\n          head: this.cm.posFromIndex(range.head)\n        };\n      }\n\n      this.cm.setSelections(ranges);\n    }\n  }, {\n    key: \"addStyleRule\",\n    value: function addStyleRule(css) {\n      if (this.addedStyle[css]) {\n        return;\n      }\n\n      this.addedStyle[css] = true;\n      this.styleSheet.insertRule(css, (this.styleSheet.cssRules || this.styleSheet.rules).length);\n    } // var addStyleRule = (function () {\n    //   var added = {};\n    //   var styleElement = document.createElement('style');\n    //   document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);\n    //   var styleSheet = styleElement.sheet;\n    //   return function (css) {\n    //     if (added[css]) { return; }\n    //     added[css] = true;\n    //     styleSheet.insertRule(css, (styleSheet.cssRules || styleSheet.rules).length);\n    //   };\n    // }());\n\n  }, {\n    key: \"setOtherCursor\",\n    value: function setOtherCursor(position, color, clientId) {\n      var cursorPos = this.cm.posFromIndex(position);\n      var cursorCoords = this.cm.cursorCoords(cursorPos);\n      var cursorEl = document.createElement('span');\n      cursorEl.className = 'other-client';\n      cursorEl.style.display = 'inline-block';\n      cursorEl.style.padding = '0';\n      cursorEl.style.marginLeft = cursorEl.style.marginRight = '-1px';\n      cursorEl.style.borderLeftWidth = '2px';\n      cursorEl.style.borderLeftStyle = 'solid';\n      cursorEl.style.borderLeftColor = color;\n      cursorEl.style.height = (cursorCoords.bottom - cursorCoords.top) * 0.9 + 'px';\n      cursorEl.style.zIndex = 0;\n      cursorEl.setAttribute('data-clientid', clientId);\n      return this.cm.setBookmark(cursorPos, {\n        widget: cursorEl,\n        insertLeft: true\n      });\n    }\n  }, {\n    key: \"setOtherSelectionRange\",\n    value: function setOtherSelectionRange(range, color, clientId) {\n      var match = /^#([0-9a-fA-F]{6})$/.exec(color);\n\n      if (!match) {\n        throw new Error(\"only six-digit hex colors are allowed.\");\n      }\n\n      var selectionClassName = 'selection-' + match[1];\n\n      var rgbcolor = this._hex2rgb(color);\n\n      var rule = '.' + selectionClassName + ' { background: rgba(' + rgbcolor.red + ',' + rgbcolor.green + ',' + rgbcolor.blue + ',0.2); }'; // XXX: Right way? (by kaishuu0123)\n\n      this.addStyleRule(rule);\n      var anchorPos = this.cm.posFromIndex(range.anchor);\n      var headPos = this.cm.posFromIndex(range.head);\n      return this.cm.markText(minPos(anchorPos, headPos), maxPos(anchorPos, headPos), {\n        className: selectionClassName\n      });\n    }\n  }, {\n    key: \"setOtherSelection\",\n    value: function setOtherSelection(selection, color, clientId) {\n      var selectionObjects = [];\n\n      for (var i = 0; i < selection.ranges.length; i++) {\n        var range = selection.ranges[i];\n        console.log(range);\n        console.log(range.isEmpty());\n\n        if (range.isEmpty()) {\n          selectionObjects[i] = this.setOtherCursor(range.head, color, clientId);\n        } else {\n          selectionObjects[i] = this.setOtherSelectionRange(range, color, clientId);\n        }\n      }\n\n      return {\n        clear: function clear() {\n          for (var i = 0; i < selectionObjects.length; i++) {\n            if (selectionObjects[i]) {\n              selectionObjects[i].clear();\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var action = this.callbacks && this.callbacks[event];\n\n      if (action) {\n        action.apply(this, args);\n      }\n    }\n  }, {\n    key: \"applyOperation\",\n    value: function applyOperation(operation) {\n      if (!operation.isNoop()) {\n        this.ignoreNextChange = true;\n      }\n\n      CodeMirrorAdapter.applyOperationToCodeMirror(operation, this.cm);\n    }\n  }, {\n    key: \"registerUndo\",\n    value: function registerUndo(undoFn) {\n      this.cm.undo = undoFn;\n    }\n  }, {\n    key: \"registerRedo\",\n    value: function registerRedo(redoFn) {\n      this.cm.redo = redoFn;\n    }\n  }, {\n    key: \"_assert\",\n    // Throws an error if the first argument is falsy. Useful for debugging.\n    value: function _assert(b, msg) {\n      if (!b) {\n        throw new Error(msg || \"assertion error\");\n      }\n    } // Bind a method to an object, so it doesn't matter whether you call\n    // object.method() directly or pass object.method as a reference to another\n    // function.\n\n  }, {\n    key: \"_bind\",\n    value: function _bind(obj, method) {\n      var fn = obj[method];\n\n      obj[method] = function () {\n        fn.apply(obj, arguments);\n      };\n    }\n  }, {\n    key: \"_hex2rgb\",\n    value: function _hex2rgb(hex) {\n      if (hex[0] === \"#\") {\n        hex = hex.substr(1);\n      }\n\n      if (hex.length === 3) {\n        var temp = hex;\n        hex = '';\n        temp = /^([a-f0-9])([a-f0-9])([a-f0-9])$/i.exec(temp).slice(1);\n\n        for (var i = 0; i < 3; i++) {\n          hex += temp[i] + temp[i];\n        }\n      }\n\n      var triplets = /^([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex).slice(1);\n      return {\n        red: parseInt(triplets[0], 16),\n        green: parseInt(triplets[1], 16),\n        blue: parseInt(triplets[2], 16)\n      };\n    }\n  }]);\n\n  return CodeMirrorAdapter;\n}();\n\n_defineProperty(CodeMirrorAdapter, \"operationFromCodeMirrorChanges\", operationFromCodeMirrorChanges);\n\n_defineProperty(CodeMirrorAdapter, \"operationFromCodeMirrorChange\", operationFromCodeMirrorChanges);\n\n_defineProperty(CodeMirrorAdapter, \"applyOperationToCodeMirror\", function (operation, cm) {\n  cm.operation(function () {\n    var ops = operation.ops;\n    var index = 0; // holds the current index into CodeMirror's content\n\n    for (var i = 0, l = ops.length; i < l; i++) {\n      var op = ops[i];\n\n      if (common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isRetain(op)) {\n        index += op;\n      } else if (common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isInsert(op)) {\n        var position = cm.getCursor();\n        var indexPos = cm.posFromIndex(index);\n        cm.replaceRange(op, indexPos, null, 'ignoreHistory');\n\n        if (position.line === indexPos.line && position.ch === indexPos.ch) {\n          cm.setCursor(position);\n        }\n\n        index += op.length;\n      } else if (common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDelete(op)) {\n        var from = cm.posFromIndex(index);\n        var to = cm.posFromIndex(index - op);\n        cm.replaceRange('', from, to, 'ignoreHistory');\n      }\n    }\n  });\n});\n\n\n\n//# sourceURL=webpack://ot_es/./src/browser/codemirror-adapter.js?");

/***/ }),

/***/ "./src/browser/editor-client.js":
/*!**************************************!*\
  !*** ./src/browser/editor-client.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EditorClient; });\n/* harmony import */ var browser_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! browser/client */ \"./src/browser/client.js\");\n/* harmony import */ var common_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/selection */ \"./src/common/selection.js\");\n/* harmony import */ var browser_undo_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! browser/undo-manager */ \"./src/browser/undo-manager.js\");\n/* harmony import */ var common_text_operation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/text-operation */ \"./src/common/text-operation.js\");\n/* harmony import */ var common_wrapped_operation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/wrapped-operation */ \"./src/common/wrapped-operation.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\nvar OtherClient =\n/*#__PURE__*/\nfunction () {\n  function OtherClient(id, listEl, editorAdapter, name, color, selection) {\n    _classCallCheck(this, OtherClient);\n\n    this.id = id;\n    this.listEl = listEl;\n    this.editorAdapter = editorAdapter;\n    this.name = name;\n    this.color = color;\n    this.li = document.createElement('li');\n\n    if (name) {\n      this.li.textContent = name;\n      this.listEl.appendChild(this.li);\n    }\n\n    if (!color) {\n      this.setColor(name ? this._hueFromName(name) : Math.random());\n    } else {\n      this.setForceColor(color);\n    }\n\n    if (selection) {\n      this.updateSelection(selection);\n    }\n  }\n\n  _createClass(OtherClient, [{\n    key: \"setColor\",\n    value: function setColor(hue) {\n      this.hue = hue;\n      this.color = this._hsl2hex(hue, 0.75, 0.5);\n      this.lightColor = this._hsl2hex(hue, 0.5, 0.9);\n\n      if (this.li) {\n        this.li.style.color = this.color;\n      }\n    }\n  }, {\n    key: \"setForceColor\",\n    value: function setForceColor(color) {\n      this.hue = null;\n      this.color = color;\n      this.lightColor = color;\n\n      if (this.li) {\n        this.li.style.color = this.color;\n      }\n    }\n  }, {\n    key: \"setName\",\n    value: function setName(name) {\n      if (this.name === name) {\n        return;\n      }\n\n      this.name = name;\n      this.li.textContent = name;\n\n      if (!this.li.parentNode) {\n        this.listEl.appendChild(this.li);\n      }\n\n      this.setColor(this._hueFromName(name));\n    }\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection(selection) {\n      this.removeSelection();\n      this.selection = selection;\n      this.mark = this.editorAdapter.setOtherSelection(selection, selection.position === selection.selectionEnd ? this.color : this.lightColor, this.id);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (this.li) {\n        this._removeElement(this.li);\n      }\n\n      this.removeSelection();\n    }\n  }, {\n    key: \"removeSelection\",\n    value: function removeSelection() {\n      if (this.mark) {\n        this.mark.clear();\n        this.mark = null;\n      }\n    }\n  }, {\n    key: \"_rgb2hex\",\n    value: function _rgb2hex(r, g, b) {\n      function digits(n) {\n        var m = Math.round(255 * n).toString(16);\n        return m.length === 1 ? '0' + m : m;\n      }\n\n      return '#' + digits(r) + digits(g) + digits(b);\n    }\n  }, {\n    key: \"_hsl2hex\",\n    value: function _hsl2hex(h, s, l) {\n      if (s === 0) {\n        return this._rgb2hex(l, l, l);\n      }\n\n      var var2 = l < 0.5 ? l * (1 + s) : l + s - s * l;\n      var var1 = 2 * l - var2;\n\n      var hue2rgb = function hue2rgb(hue) {\n        if (hue < 0) {\n          hue += 1;\n        }\n\n        if (hue > 1) {\n          hue -= 1;\n        }\n\n        if (6 * hue < 1) {\n          return var1 + (var2 - var1) * 6 * hue;\n        }\n\n        if (2 * hue < 1) {\n          return var2;\n        }\n\n        if (3 * hue < 2) {\n          return var1 + (var2 - var1) * 6 * (2 / 3 - hue);\n        }\n\n        return var1;\n      };\n\n      return this._rgb2hex(hue2rgb(h + 1 / 3), hue2rgb(h), hue2rgb(h - 1 / 3));\n    }\n  }, {\n    key: \"_hueFromName\",\n    value: function _hueFromName(name) {\n      var a = 1;\n\n      for (var i = 0; i < name.length; i++) {\n        a = 17 * (a + name.charCodeAt(i)) % 360;\n      }\n\n      return a / 360;\n    }\n  }, {\n    key: \"_removeElement\",\n    value: function _removeElement(el) {\n      if (el.parentNode) {\n        el.parentNode.removeChild(el);\n      }\n    }\n  }]);\n\n  return OtherClient;\n}();\n\nvar OtherMeta =\n/*#__PURE__*/\nfunction () {\n  function OtherMeta(clientId, selection) {\n    _classCallCheck(this, OtherMeta);\n\n    this.clientId = clientId;\n    this.selection = selection;\n  }\n\n  _createClass(OtherMeta, [{\n    key: \"transform\",\n    value: function transform(operation) {\n      return new OtherMeta(this.clientId, this.selection && this.selection.transform(operation));\n    }\n  }]);\n\n  return OtherMeta;\n}();\n\n_defineProperty(OtherMeta, \"fromJSON\", function (obj) {\n  return new OtherMeta(obj.clientId, obj.selection && common_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJSON(obj.selection));\n});\n\nvar SelfMeta =\n/*#__PURE__*/\nfunction () {\n  function SelfMeta(selectionBefore, selectionAfter) {\n    _classCallCheck(this, SelfMeta);\n\n    this.selectionBefore = selectionBefore;\n    this.selectionAfter = selectionAfter;\n  }\n\n  _createClass(SelfMeta, [{\n    key: \"invert\",\n    value: function invert() {\n      return new SelfMeta(this.selectionAfter, this.selectionBefore);\n    }\n  }, {\n    key: \"compose\",\n    value: function compose(other) {\n      return new SelfMeta(this.selectionBefore, other.selectionAfter);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(operation) {\n      return new SelfMeta(this.selectionBefore ? this.selectionBefore.transform(operation) : null, this.selectionAfter ? this.selectionAfter.transform(operation) : null);\n    }\n  }]);\n\n  return SelfMeta;\n}();\n\nvar EditorClient =\n/*#__PURE__*/\nfunction (_Client) {\n  _inherits(EditorClient, _Client);\n\n  function EditorClient(revision, clients, serverAdapter, editorAdapter) {\n    var _this;\n\n    _classCallCheck(this, EditorClient);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditorClient).call(this, revision));\n    _this.serverAdapter = serverAdapter;\n    _this.editorAdapter = editorAdapter;\n    _this.undoManager = new browser_undo_manager__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n\n    _this.initializeClientList();\n\n    _this.initializeClients(clients);\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n    _this.editorAdapter.registerCallbacks({\n      change: function change(operation, inverse) {\n        self.onChange(operation, inverse);\n      },\n      selectionChange: function selectionChange() {\n        self.onSelectionChange();\n      },\n      blur: function blur() {\n        self.onBlur();\n      }\n    });\n\n    _this.editorAdapter.registerUndo(function () {\n      self.undo();\n    });\n\n    _this.editorAdapter.registerRedo(function () {\n      self.redo();\n    });\n\n    _this.serverAdapter.registerCallbacks({\n      client_left: function client_left(clientId) {\n        self.onClientLeft(clientId);\n      },\n      set_name: function set_name(clientId, name) {\n        self.getClientObject(clientId).setName(name);\n      },\n      set_color: function set_color(clientId, color) {\n        self.getClientObject(clientId).setForceColor(color);\n      },\n      ack: function ack(revision) {\n        self.serverAck(revision);\n      },\n      operation: function operation(revision, _operation) {\n        self.applyServer(revision, common_text_operation__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromJSON(_operation));\n      },\n      operations: function operations(head, _operations) {\n        self.applyOperations(head, _operations);\n      },\n      selection: function selection(clientId, _selection) {\n        if (_selection) {\n          self.getClientObject(clientId).updateSelection(self.transformSelection(common_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJSON(_selection)));\n        } else {\n          self.getClientObject(clientId).removeSelection();\n        }\n      },\n      clients: function clients(_clients) {\n        var clientId;\n\n        for (clientId in self.clients) {\n          if (self.clients.hasOwnProperty(clientId) && !_clients.hasOwnProperty(clientId)) {\n            self.onClientLeft(clientId);\n          }\n        }\n\n        for (clientId in _clients) {\n          if (_clients.hasOwnProperty(clientId)) {\n            var clientObject = self.getClientObject(clientId);\n\n            if (_clients[clientId].name) {\n              clientObject.setName(_clients[clientId].name);\n            }\n\n            var selection = _clients[clientId].selection;\n\n            if (selection) {\n              self.clients[clientId].updateSelection(self.transformSelection(common_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJSON(selection)));\n            } else {\n              self.clients[clientId].removeSelection();\n            }\n          }\n        }\n      },\n      reconnect: function reconnect() {\n        self.serverReconnect();\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(EditorClient, [{\n    key: \"addClient\",\n    value: function addClient(clientId, clientObj) {\n      this.clients[clientId] = new OtherClient(clientId, this.clientListEl, this.editorAdapter, clientObj.name || clientId, clientObj.color || null, clientObj.selection ? common_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJSON(clientObj.selection) : null);\n    }\n  }, {\n    key: \"initializeClients\",\n    value: function initializeClients(clients) {\n      this.clients = {};\n\n      for (var clientId in clients) {\n        if (clients.hasOwnProperty(clientId)) {\n          this.addClient(clientId, clients[clientId]);\n        }\n      }\n    }\n  }, {\n    key: \"getClientObject\",\n    value: function getClientObject(clientId) {\n      var client = this.clients[clientId];\n\n      if (client) {\n        return client;\n      }\n\n      return this.clients[clientId] = new OtherClient(clientId, this.clientListEl, this.editorAdapter);\n    }\n  }, {\n    key: \"onClientLeft\",\n    value: function onClientLeft(clientId) {\n      var client = this.clients[clientId];\n\n      if (!client) {\n        return;\n      }\n\n      client.remove();\n      delete this.clients[clientId];\n    }\n  }, {\n    key: \"initializeClientList\",\n    value: function initializeClientList() {\n      this.clientListEl = document.createElement('ul');\n    }\n  }, {\n    key: \"applyUnredo\",\n    value: function applyUnredo(operation) {\n      this.undoManager.add(operation.invert(this.editorAdapter.getValue()));\n      this.editorAdapter.applyOperation(operation.wrapped);\n      this.selection = operation.meta.selectionAfter;\n      this.editorAdapter.setSelection(this.selection);\n      this.applyClient(operation.wrapped);\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      var self = this;\n\n      if (!this.undoManager.canUndo()) {\n        return;\n      }\n\n      this.undoManager.performUndo(function (o) {\n        self.applyUnredo(o);\n      });\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      var self = this;\n\n      if (!this.undoManager.canRedo()) {\n        return;\n      }\n\n      this.undoManager.performRedo(function (o) {\n        self.applyUnredo(o);\n      });\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(textOperation, inverse) {\n      var selectionBefore = this.selection;\n      this.updateSelection();\n      var meta = new SelfMeta(selectionBefore, this.selection);\n      var operation = new common_wrapped_operation__WEBPACK_IMPORTED_MODULE_4__[\"default\"](textOperation, meta);\n      var compose = this.undoManager.undoStack.length > 0 && inverse.shouldBeComposedWithInverted(this._last(this.undoManager.undoStack).wrapped);\n      var inverseMeta = new SelfMeta(this.selection, selectionBefore);\n      this.undoManager.add(new common_wrapped_operation__WEBPACK_IMPORTED_MODULE_4__[\"default\"](inverse, inverseMeta), compose);\n      this.applyClient(textOperation);\n    }\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      this.selection = this.editorAdapter.getSelection();\n    }\n  }, {\n    key: \"onSelectionChange\",\n    value: function onSelectionChange() {\n      var oldSelection = this.selection;\n      this.updateSelection();\n\n      if (oldSelection && this.selection.equals(oldSelection)) {\n        return;\n      }\n\n      this.sendSelection(this.selection);\n    }\n  }, {\n    key: \"onBlur\",\n    value: function onBlur() {\n      this.selection = null;\n      this.sendSelection(null);\n    }\n  }, {\n    key: \"sendSelection\",\n    value: function sendSelection(selection) {\n      if (this.state instanceof browser_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"].AwaitingWithBuffer) {\n        return;\n      }\n\n      this.serverAdapter.sendSelection(selection);\n    }\n  }, {\n    key: \"sendOperation\",\n    value: function sendOperation(revision, operation) {\n      this.serverAdapter.sendOperation(revision, operation.toJSON(), this.selection);\n    }\n  }, {\n    key: \"getOperations\",\n    value: function getOperations(base, head) {\n      this.serverAdapter.getOperations(base, head);\n    }\n  }, {\n    key: \"applyOperation\",\n    value: function applyOperation(operation) {\n      this.editorAdapter.applyOperation(operation);\n      this.updateSelection();\n      this.undoManager.transform(new common_wrapped_operation__WEBPACK_IMPORTED_MODULE_4__[\"default\"](operation, null));\n    }\n  }, {\n    key: \"_last\",\n    value: function _last(arr) {\n      return arr[arr.length - 1];\n    }\n  }]);\n\n  return EditorClient;\n}(browser_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://ot_es/./src/browser/editor-client.js?");

/***/ }),

/***/ "./src/browser/socketio-adapter.js":
/*!*****************************************!*\
  !*** ./src/browser/socketio-adapter.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SocketIOAdapter; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SocketIOAdapter =\n/*#__PURE__*/\nfunction () {\n  function SocketIOAdapter(socket) {\n    _classCallCheck(this, SocketIOAdapter);\n\n    this.socket = socket;\n    var self = this;\n    socket.on('client_left', function (clientId) {\n      self.trigger('client_left', clientId);\n    }).on('set_name', function (clientId, name) {\n      self.trigger('set_name', clientId, name);\n    }).on('set_color', function (clientId, color) {\n      self.trigger('set_color', clientId, color);\n    }).on('ack', function (revision) {\n      self.trigger('ack', revision);\n    }).on('operation', function (clientId, revision, operation, selection) {\n      self.trigger('operation', revision, operation);\n      self.trigger('selection', clientId, selection);\n    }).on('operations', function (head, operations) {\n      self.trigger('operations', head, operations);\n    }).on('selection', function (clientId, selection) {\n      self.trigger('selection', clientId, selection);\n    }).on('reconnect', function () {\n      self.trigger('reconnect');\n    });\n  }\n\n  _createClass(SocketIOAdapter, [{\n    key: \"sendOperation\",\n    value: function sendOperation(revision, operation, selection) {\n      this.socket.emit('operation', revision, operation, selection);\n    }\n  }, {\n    key: \"sendSelection\",\n    value: function sendSelection(selection) {\n      this.socket.emit('selection', selection);\n    }\n  }, {\n    key: \"getOperations\",\n    value: function getOperations(base, head) {\n      this.socket.emit('get_operations', base, head);\n    }\n  }, {\n    key: \"registerCallbacks\",\n    value: function registerCallbacks(cb) {\n      this.callbacks = cb;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var action = this.callbacks && this.callbacks[event];\n\n      if (action) {\n        action.apply(this, args);\n      }\n    }\n  }]);\n\n  return SocketIOAdapter;\n}();\n\n\n\n//# sourceURL=webpack://ot_es/./src/browser/socketio-adapter.js?");

/***/ }),

/***/ "./src/browser/undo-manager.js":
/*!*************************************!*\
  !*** ./src/browser/undo-manager.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return UndoManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar NORMAL_STATE = 'normal';\nvar UNDOING_STATE = 'undoing';\nvar REDOING_STATE = 'redoing';\n\nvar UndoManager =\n/*#__PURE__*/\nfunction () {\n  // Create a new UndoManager with an optional maximum history size.\n  function UndoManager(maxItems) {\n    _classCallCheck(this, UndoManager);\n\n    this.maxItems = maxItems || 50;\n    this.state = NORMAL_STATE;\n    this.dontCompose = false;\n    this.undoStack = [];\n    this.redoStack = [];\n  } // Add an operation to the undo or redo stack, depending on the current state\n  // of the UndoManager. The operation added must be the inverse of the last\n  // edit. When `compose` is true, compose the operation with the last operation\n  // unless the last operation was alread pushed on the redo stack or was hidden\n  // by a newer operation on the undo stack.\n\n\n  _createClass(UndoManager, [{\n    key: \"add\",\n    value: function add(operation, compose) {\n      if (this.state === UNDOING_STATE) {\n        this.redoStack.push(operation);\n        this.dontCompose = true;\n      } else if (this.state === REDOING_STATE) {\n        this.undoStack.push(operation);\n        this.dontCompose = true;\n      } else {\n        var undoStack = this.undoStack;\n\n        if (!this.dontCompose && compose && undoStack.length > 0) {\n          undoStack.push(operation.compose(undoStack.pop()));\n        } else {\n          undoStack.push(operation);\n\n          if (undoStack.length > this.maxItems) {\n            undoStack.shift();\n          }\n        }\n\n        this.dontCompose = false;\n        this.redoStack = [];\n      }\n    }\n  }, {\n    key: \"_transformStack\",\n    value: function _transformStack(stack, operation) {\n      var newStack = [];\n      var Operation = operation.constructor;\n\n      for (var i = stack.length - 1; i >= 0; i--) {\n        var pair = Operation.transform(stack[i], operation);\n\n        if (typeof pair[0].isNoop !== 'function' || !pair[0].isNoop()) {\n          newStack.push(pair[0]);\n        }\n\n        operation = pair[1];\n      }\n\n      return newStack.reverse();\n    } // Transform the undo and redo stacks against a operation by another client.\n\n  }, {\n    key: \"transform\",\n    value: function transform(operation) {\n      this.undoStack = this._transformStack(this.undoStack, operation);\n      this.redoStack = this._transformStack(this.redoStack, operation);\n    }\n  }, {\n    key: \"performUndo\",\n    // Perform an undo by calling a function with the latest operation on the undo\n    // stack. The function is expected to call the `add` method with the inverse\n    // of the operation, which pushes the inverse on the redo stack.\n    value: function performUndo(fn) {\n      this.state = UNDOING_STATE;\n\n      if (this.undoStack.length === 0) {\n        throw new Error(\"undo not possible\");\n      }\n\n      fn(this.undoStack.pop());\n      this.state = NORMAL_STATE;\n    }\n  }, {\n    key: \"performRedo\",\n    // The inverse of `performUndo`.\n    value: function performRedo(fn) {\n      this.state = REDOING_STATE;\n\n      if (this.redoStack.length === 0) {\n        throw new Error(\"redo not possible\");\n      }\n\n      fn(this.redoStack.pop());\n      this.state = NORMAL_STATE;\n    }\n  }, {\n    key: \"canUndo\",\n    // Is the undo stack not empty?\n    value: function canUndo() {\n      return this.undoStack.length !== 0;\n    }\n  }, {\n    key: \"canRedo\",\n    // Is the redo stack not empty?\n    value: function canRedo() {\n      return this.redoStack.length !== 0;\n    }\n  }, {\n    key: \"isUndoing\",\n    // Whether the UndoManager is currently performing an undo.\n    value: function isUndoing() {\n      return this.state === UNDOING_STATE;\n    }\n  }, {\n    key: \"isRedoing\",\n    // Whether the UndoManager is currently performing a redo.\n    value: function isRedoing() {\n      return this.state === REDOING_STATE;\n    }\n  }]);\n\n  return UndoManager;\n}();\n\n\n\n//# sourceURL=webpack://ot_es/./src/browser/undo-manager.js?");

/***/ }),

/***/ "./src/common/selection.js":
/*!*********************************!*\
  !*** ./src/common/selection.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Selection; });\n/* harmony import */ var common_text_operation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/text-operation */ \"./src/common/text-operation.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar Range =\n/*#__PURE__*/\nfunction () {\n  // Range has `anchor` and `head` properties, which are zero-based indices into\n  // the document. The `anchor` is the side of the selection that stays fixed,\n  // `head` is the side of the selection where the cursor is. When both are\n  // equal, the range represents a cursor.\n  function Range(anchor, head) {\n    _classCallCheck(this, Range);\n\n    this.anchor = anchor;\n    this.head = head;\n  }\n\n  _createClass(Range, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return this.anchor === other.anchor && this.head === other.head;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.anchor === this.head;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(other) {\n      function transformIndex(index) {\n        var newIndex = index;\n        var ops = other.ops;\n\n        for (var i = 0, l = other.ops.length; i < l; i++) {\n          if (common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isRetain(ops[i])) {\n            index -= ops[i];\n          } else if (common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isInsert(ops[i])) {\n            newIndex += ops[i].length;\n          } else {\n            newIndex -= Math.min(index, -ops[i]);\n            index += ops[i];\n          }\n\n          if (index < 0) {\n            break;\n          }\n        }\n\n        return newIndex;\n      }\n\n      var newAnchor = transformIndex(this.anchor);\n\n      if (this.anchor === this.head) {\n        return new Range(newAnchor, newAnchor);\n      }\n\n      return new Range(newAnchor, transformIndex(this.head));\n    }\n  }]);\n\n  return Range;\n}();\n\n_defineProperty(Range, \"fromJSON\", function (obj) {\n  return new Range(obj.anchor, obj.head);\n});\n\nvar Selection =\n/*#__PURE__*/\nfunction () {\n  // A selection is basically an array of ranges. Every range represents a real\n  // selection or a cursor in the document (when the start position equals the\n  // end position of the range). The array must not be empty.\n  function Selection(ranges) {\n    _classCallCheck(this, Selection);\n\n    this.ranges = ranges || [];\n  }\n\n  _createClass(Selection, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.position !== other.position) {\n        return false;\n      }\n\n      if (this.ranges.length !== other.ranges.length) {\n        return false;\n      } // FIXME: Sort ranges before comparing them?\n\n\n      for (var i = 0; i < this.ranges.length; i++) {\n        if (!this.ranges[i].equals(other.ranges[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"somethingSelected\",\n    value: function somethingSelected() {\n      for (var i = 0; i < this.ranges.length; i++) {\n        if (!this.ranges[i].isEmpty()) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"compose\",\n    // Return the more current selection information.\n    value: function compose(other) {\n      return other;\n    }\n  }, {\n    key: \"transform\",\n    // Update the selection with respect to an operation.\n    value: function transform(other) {\n      for (var i = 0, newRanges = []; i < this.ranges.length; i++) {\n        newRanges[i] = this.ranges[i].transform(other);\n      }\n\n      return new Selection(newRanges);\n    }\n  }]);\n\n  return Selection;\n}();\n\n_defineProperty(Selection, \"Range\", Range);\n\n_defineProperty(Selection, \"createCursor\", function (position) {\n  return new Selection([new Range(position, position)]);\n});\n\n_defineProperty(Selection, \"fromJSON\", function (obj) {\n  var objRanges = obj.ranges || obj;\n\n  for (var i = 0, ranges = []; i < objRanges.length; i++) {\n    ranges[i] = Range.fromJSON(objRanges[i]);\n  }\n\n  return new Selection(ranges);\n});\n\n\n\n//# sourceURL=webpack://ot_es/./src/common/selection.js?");

/***/ }),

/***/ "./src/common/simple-text-operation.js":
/*!*********************************************!*\
  !*** ./src/common/simple-text-operation.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SimpleTextOperation; });\n/* harmony import */ var common_text_operation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/text-operation */ \"./src/common/text-operation.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Delete =\n/*#__PURE__*/\nfunction () {\n  // Delete `count` many characters at the zero-based `position` in the document.\n  function Delete(count, position) {\n    _classCallCheck(this, Delete);\n\n    this.count = count;\n    this.position = position;\n  }\n\n  _createClass(Delete, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'Delete(' + this.count + ', ' + this.position + ')';\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof Delete && this.count === other.count && this.position === other.position;\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(doc) {\n      return doc.slice(0, this.position) + doc.slice(this.position + this.count);\n    }\n  }]);\n\n  return Delete;\n}();\n\nvar Insert =\n/*#__PURE__*/\nfunction () {\n  // Insert the string `str` at the zero-based `position` in the document.\n  function Insert(str, position) {\n    _classCallCheck(this, Insert);\n\n    this.str = str;\n    this.position = position;\n  }\n\n  _createClass(Insert, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'Insert(' + JSON.stringify(this.str) + ', ' + this.position + ')';\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof Insert && this.str === other.str && this.position === other.position;\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(doc) {\n      return doc.slice(0, this.position) + this.str + doc.slice(this.position);\n    }\n  }]);\n\n  return Insert;\n}(); // An operation that does nothing. This is needed for the result of the\n// transformation of two deletions of the same character.\n\n\nvar Noop =\n/*#__PURE__*/\nfunction () {\n  function Noop() {\n    _classCallCheck(this, Noop);\n  }\n\n  _createClass(Noop, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'Noop()';\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof Noop;\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(doc) {\n      return doc;\n    }\n  }]);\n\n  return Noop;\n}();\n\nvar noop = new Noop();\n\nvar SimpleTextOperation = function SimpleTextOperation() {\n  _classCallCheck(this, SimpleTextOperation);\n};\n\n_defineProperty(SimpleTextOperation, \"Insert\", Insert);\n\n_defineProperty(SimpleTextOperation, \"Delete\", Delete);\n\n_defineProperty(SimpleTextOperation, \"Noop\", Noop);\n\n_defineProperty(SimpleTextOperation, \"transform\", function (a, b) {\n  if (a instanceof Noop || b instanceof Noop) {\n    return [a, b];\n  }\n\n  if (a instanceof Insert && b instanceof Insert) {\n    if (a.position < b.position || a.position === b.position && a.str < b.str) {\n      return [a, new Insert(b.str, b.position + a.str.length)];\n    }\n\n    if (a.position > b.position || a.position === b.position && a.str > b.str) {\n      return [new Insert(a.str, a.position + b.str.length), b];\n    }\n\n    return [noop, noop];\n  }\n\n  if (a instanceof Insert && b instanceof Delete) {\n    if (a.position <= b.position) {\n      return [a, new Delete(b.count, b.position + a.str.length)];\n    }\n\n    if (a.position >= b.position + b.count) {\n      return [new Insert(a.str, a.position - b.count), b];\n    } // Here, we have to delete the inserted string of operation a.\n    // That doesn't preserve the intention of operation a, but it's the only\n    // thing we can do to get a valid transform function.\n\n\n    return [noop, new Delete(b.count + a.str.length, b.position)];\n  }\n\n  if (a instanceof Delete && b instanceof Insert) {\n    if (a.position >= b.position) {\n      return [new Delete(a.count, a.position + b.str.length), b];\n    }\n\n    if (a.position + a.count <= b.position) {\n      return [a, new Insert(b.str, b.position - a.count)];\n    } // Same problem as above. We have to delete the string that was inserted\n    // in operation b.\n\n\n    return [new Delete(a.count + b.str.length, a.position), noop];\n  }\n\n  if (a instanceof Delete && b instanceof Delete) {\n    if (a.position === b.position) {\n      if (a.count === b.count) {\n        return [noop, noop];\n      } else if (a.count < b.count) {\n        return [noop, new Delete(b.count - a.count, b.position)];\n      }\n\n      return [new Delete(a.count - b.count, a.position), noop];\n    }\n\n    if (a.position < b.position) {\n      if (a.position + a.count <= b.position) {\n        return [a, new Delete(b.count, b.position - a.count)];\n      }\n\n      if (a.position + a.count >= b.position + b.count) {\n        return [new Delete(a.count - b.count, a.position), noop];\n      }\n\n      return [new Delete(b.position - a.position, a.position), new Delete(b.position + b.count - (a.position + a.count), a.position)];\n    }\n\n    if (a.position > b.position) {\n      if (a.position >= b.position + b.count) {\n        return [new Delete(a.count, a.position - b.count), b];\n      }\n\n      if (a.position + a.count <= b.position + b.count) {\n        return [noop, new Delete(b.count - a.count, b.position)];\n      }\n\n      return [new Delete(a.position + a.count - (b.position + b.count), b.position), new Delete(a.position - b.position, b.position)];\n    }\n  }\n});\n\n_defineProperty(SimpleTextOperation, \"fromTextOperation\", function (operation) {\n  var simpleOperations = [];\n  var index = 0;\n\n  for (var i = 0; i < operation.ops.length; i++) {\n    var op = operation.ops[i];\n\n    if (common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isRetain(op)) {\n      index += op;\n    } else if (common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isInsert(op)) {\n      simpleOperations.push(new Insert(op, index));\n      index += op.length;\n    } else {\n      simpleOperations.push(new Delete(Math.abs(op), index));\n    }\n  }\n\n  return simpleOperations;\n});\n\n\n\n//# sourceURL=webpack://ot_es/./src/common/simple-text-operation.js?");

/***/ }),

/***/ "./src/common/text-operation.js":
/*!**************************************!*\
  !*** ./src/common/text-operation.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TextOperation; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Operation are essentially lists of ops. There are three types of ops:\n//\n// * Retain ops: Advance the cursor position by a given number of characters.\n//   Represented by positive ints.\n// * Insert ops: Insert a given string at the current cursor position.\n//   Represented by strings.\n// * Delete ops: Delete the next n characters. Represented by negative ints.\nvar isRetain = function isRetain(op) {\n  return typeof op === 'number' && op > 0;\n};\n\nvar isInsert = function isInsert(op) {\n  return typeof op === 'string';\n};\n\nvar isDelete = function isDelete(op) {\n  return typeof op === 'number' && op < 0;\n};\n\nvar TextOperation =\n/*#__PURE__*/\nfunction () {\n  // Constructor for new operations.\n  function TextOperation() {\n    _classCallCheck(this, TextOperation);\n\n    if (!this || this.constructor !== TextOperation) {\n      // => function was called without 'new'\n      return new TextOperation();\n    } // When an operation is applied to an input string, you can think of this as\n    // if an imaginary cursor runs over the entire string and skips over some\n    // parts, deletes some parts and inserts characters at some positions. These\n    // actions (skip/delete/insert) are stored as an array in the \"ops\" property.\n\n\n    this.ops = []; // An operation's baseLength is the length of every string the operation\n    // can be applied to.\n\n    this.baseLength = 0; // The targetLength is the length of every string that results from applying\n    // the operation on a valid input string.\n\n    this.targetLength = 0;\n  }\n\n  _createClass(TextOperation, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.baseLength !== other.baseLength) {\n        return false;\n      }\n\n      if (this.targetLength !== other.targetLength) {\n        return false;\n      }\n\n      if (this.ops.length !== other.ops.length) {\n        return false;\n      }\n\n      for (var i = 0; i < this.ops.length; i++) {\n        if (this.ops[i] !== other.ops[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"retain\",\n    // After an operation is constructed, the user of the library can specify the\n    // actions of an operation (skip/insert/delete) with these three builder\n    // methods. They all return the operation for convenient chaining.\n    // Skip over a given number of characters.\n    value: function retain(n) {\n      if (typeof n !== 'number') {\n        throw new Error(\"retain expects an integer\");\n      }\n\n      if (n === 0) {\n        return this;\n      }\n\n      this.baseLength += n;\n      this.targetLength += n;\n\n      if (isRetain(this.ops[this.ops.length - 1])) {\n        // The last op is a retain op => we can merge them into one op.\n        this.ops[this.ops.length - 1] += n;\n      } else {\n        // Create a new op.\n        this.ops.push(n);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"insert\",\n    // Insert a string at the current position.\n    value: function insert(str) {\n      if (typeof str !== 'string') {\n        throw new Error(\"insert expects a string\");\n      }\n\n      if (str === '') {\n        return this;\n      }\n\n      this.targetLength += str.length;\n      var ops = this.ops;\n\n      if (isInsert(ops[ops.length - 1])) {\n        // Merge insert op.\n        ops[ops.length - 1] += str;\n      } else if (isDelete(ops[ops.length - 1])) {\n        // It doesn't matter when an operation is applied whether the operation\n        // is delete(3), insert(\"something\") or insert(\"something\"), delete(3).\n        // Here we enforce that in this case, the insert op always comes first.\n        // This makes all operations that have the same effect when applied to\n        // a document of the right length equal in respect to the `equals` method.\n        if (isInsert(ops[ops.length - 2])) {\n          ops[ops.length - 2] += str;\n        } else {\n          ops[ops.length] = ops[ops.length - 1];\n          ops[ops.length - 2] = str;\n        }\n      } else {\n        ops.push(str);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    // Delete a string at the current position.\n    value: function _delete(n) {\n      if (typeof n === 'string') {\n        n = n.length;\n      }\n\n      if (typeof n !== 'number') {\n        throw new Error(\"delete expects an integer or a string\");\n      }\n\n      if (n === 0) {\n        return this;\n      }\n\n      if (n > 0) {\n        n = -n;\n      }\n\n      this.baseLength -= n;\n\n      if (isDelete(this.ops[this.ops.length - 1])) {\n        this.ops[this.ops.length - 1] += n;\n      } else {\n        this.ops.push(n);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"isNoop\",\n    // Tests whether this operation has no effect.\n    value: function isNoop() {\n      return this.ops.length === 0 || this.ops.length === 1 && isRetain(this.ops[0]);\n    }\n  }, {\n    key: \"toString\",\n    // Pretty printing.\n    value: function toString() {\n      // map: build a new array by applying a function to every element in an old\n      // array.\n      var map = Array.prototype.map || function (fn) {\n        var arr = this;\n        var newArr = [];\n\n        for (var i = 0, l = arr.length; i < l; i++) {\n          newArr[i] = fn(arr[i]);\n        }\n\n        return newArr;\n      };\n\n      return map.call(this.ops, function (op) {\n        if (isRetain(op)) {\n          return \"retain \" + op;\n        } else if (isInsert(op)) {\n          return \"insert '\" + op + \"'\";\n        } else {\n          return \"delete \" + -op;\n        }\n      }).join(', ');\n    }\n  }, {\n    key: \"toJSON\",\n    // Converts operation into a JSON value.\n    value: function toJSON() {\n      return this.ops;\n    }\n  }, {\n    key: \"apply\",\n    // Apply an operation to a string, returning a new string. Throws an error if\n    // there's a mismatch between the input string and the operation.\n    value: function apply(str) {\n      var operation = this;\n\n      if (str.length !== operation.baseLength) {\n        throw new Error(\"The operation's base length must be equal to the string's length.\");\n      }\n\n      var newStr = [],\n          j = 0;\n      var strIndex = 0;\n      var ops = this.ops;\n\n      for (var i = 0, l = ops.length; i < l; i++) {\n        var op = ops[i];\n\n        if (isRetain(op)) {\n          if (strIndex + op > str.length) {\n            throw new Error(\"Operation can't retain more characters than are left in the string.\");\n          } // Copy skipped part of the old string.\n\n\n          newStr[j++] = str.slice(strIndex, strIndex + op);\n          strIndex += op;\n        } else if (isInsert(op)) {\n          // Insert string.\n          newStr[j++] = op;\n        } else {\n          // delete op\n          strIndex -= op;\n        }\n      }\n\n      if (strIndex !== str.length) {\n        throw new Error(\"The operation didn't operate on the whole string.\");\n      }\n\n      return newStr.join('');\n    }\n  }, {\n    key: \"invert\",\n    // Computes the inverse of an operation. The inverse of an operation is the\n    // operation that reverts the effects of the operation, e.g. when you have an\n    // operation 'insert(\"hello \"); skip(6);' then the inverse is 'delete(\"hello \");\n    // skip(6);'. The inverse should be used for implementing undo.\n    value: function invert(str) {\n      var strIndex = 0;\n      var inverse = new TextOperation();\n      var ops = this.ops;\n\n      for (var i = 0, l = ops.length; i < l; i++) {\n        var op = ops[i];\n\n        if (isRetain(op)) {\n          inverse.retain(op);\n          strIndex += op;\n        } else if (isInsert(op)) {\n          inverse['delete'](op.length);\n        } else {\n          // delete op\n          inverse.insert(str.slice(strIndex, strIndex - op));\n          strIndex -= op;\n        }\n      }\n\n      return inverse;\n    }\n  }, {\n    key: \"compose\",\n    // Compose merges two consecutive operations into one operation, that\n    // preserves the changes of both. Or, in other words, for each input string S\n    // and a pair of consecutive operations A and B,\n    // apply(apply(S, A), B) = apply(S, compose(A, B)) must hold.\n    value: function compose(operation2) {\n      var operation1 = this;\n\n      if (operation1.targetLength !== operation2.baseLength) {\n        throw new Error(\"The base length of the second operation has to be the target length of the first operation\");\n      }\n\n      var operation = new TextOperation(); // the combined operation\n\n      var ops1 = operation1.ops,\n          ops2 = operation2.ops; // for fast access\n\n      var i1 = 0,\n          i2 = 0; // current index into ops1 respectively ops2\n\n      var op1 = ops1[i1++],\n          op2 = ops2[i2++]; // current ops\n\n      while (true) {\n        // Dispatch on the type of op1 and op2\n        if (typeof op1 === 'undefined' && typeof op2 === 'undefined') {\n          // end condition: both ops1 and ops2 have been processed\n          break;\n        }\n\n        if (isDelete(op1)) {\n          operation['delete'](op1);\n          op1 = ops1[i1++];\n          continue;\n        }\n\n        if (isInsert(op2)) {\n          operation.insert(op2);\n          op2 = ops2[i2++];\n          continue;\n        }\n\n        if (typeof op1 === 'undefined') {\n          throw new Error(\"Cannot compose operations: first operation is too short.\");\n        }\n\n        if (typeof op2 === 'undefined') {\n          throw new Error(\"Cannot compose operations: first operation is too long.\");\n        }\n\n        if (isRetain(op1) && isRetain(op2)) {\n          if (op1 > op2) {\n            operation.retain(op2);\n            op1 = op1 - op2;\n            op2 = ops2[i2++];\n          } else if (op1 === op2) {\n            operation.retain(op1);\n            op1 = ops1[i1++];\n            op2 = ops2[i2++];\n          } else {\n            operation.retain(op1);\n            op2 = op2 - op1;\n            op1 = ops1[i1++];\n          }\n        } else if (isInsert(op1) && isDelete(op2)) {\n          if (op1.length > -op2) {\n            op1 = op1.slice(-op2);\n            op2 = ops2[i2++];\n          } else if (op1.length === -op2) {\n            op1 = ops1[i1++];\n            op2 = ops2[i2++];\n          } else {\n            op2 = op2 + op1.length;\n            op1 = ops1[i1++];\n          }\n        } else if (isInsert(op1) && isRetain(op2)) {\n          if (op1.length > op2) {\n            operation.insert(op1.slice(0, op2));\n            op1 = op1.slice(op2);\n            op2 = ops2[i2++];\n          } else if (op1.length === op2) {\n            operation.insert(op1);\n            op1 = ops1[i1++];\n            op2 = ops2[i2++];\n          } else {\n            operation.insert(op1);\n            op2 = op2 - op1.length;\n            op1 = ops1[i1++];\n          }\n        } else if (isRetain(op1) && isDelete(op2)) {\n          if (op1 > -op2) {\n            operation['delete'](op2);\n            op1 = op1 + op2;\n            op2 = ops2[i2++];\n          } else if (op1 === -op2) {\n            operation['delete'](op2);\n            op1 = ops1[i1++];\n            op2 = ops2[i2++];\n          } else {\n            operation['delete'](op1);\n            op2 = op2 + op1;\n            op1 = ops1[i1++];\n          }\n        } else {\n          throw new Error(\"This shouldn't happen: op1: \" + JSON.stringify(op1) + \", op2: \" + JSON.stringify(op2));\n        }\n      }\n\n      return operation;\n    }\n  }, {\n    key: \"_getSimpleOp\",\n    value: function _getSimpleOp(operation, fn) {\n      var ops = operation.ops;\n      var isRetain = TextOperation.isRetain;\n\n      switch (ops.length) {\n        case 1:\n          return ops[0];\n\n        case 2:\n          return isRetain(ops[0]) ? ops[1] : isRetain(ops[1]) ? ops[0] : null;\n\n        case 3:\n          if (isRetain(ops[0]) && isRetain(ops[2])) {\n            return ops[1];\n          }\n\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getStartIndex\",\n    value: function _getStartIndex(operation) {\n      if (isRetain(operation.ops[0])) {\n        return operation.ops[0];\n      }\n\n      return 0;\n    } // When you use ctrl-z to undo your latest changes, you expect the program not\n    // to undo every single keystroke but to undo your last sentence you wrote at\n    // a stretch or the deletion you did by holding the backspace key down. This\n    // This can be implemented by composing operations on the undo stack. This\n    // method can help decide whether two operations should be composed. It\n    // returns true if the operations are consecutive insert operations or both\n    // operations delete text at the same position. You may want to include other\n    // factors like the time since the last change in your decision.\n\n  }, {\n    key: \"shouldBeComposedWith\",\n    value: function shouldBeComposedWith(other) {\n      if (this.isNoop() || other.isNoop()) {\n        return true;\n      }\n\n      var startA = this._getStartIndex(this),\n          startB = this._getStartIndex(other);\n\n      var simpleA = this._getSimpleOp(this),\n          simpleB = this._getSimpleOp(other);\n\n      if (!simpleA || !simpleB) {\n        return false;\n      }\n\n      if (isInsert(simpleA) && isInsert(simpleB)) {\n        return startA + simpleA.length === startB;\n      }\n\n      if (isDelete(simpleA) && isDelete(simpleB)) {\n        // there are two possibilities to delete: with backspace and with the\n        // delete key.\n        return startB - simpleB === startA || startA === startB;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"shouldBeComposedWithInverted\",\n    // Decides whether two operations should be composed with each other\n    // if they were inverted, that is\n    // `shouldBeComposedWith(a, b) = shouldBeComposedWithInverted(b^{-1}, a^{-1})`.\n    value: function shouldBeComposedWithInverted(other) {\n      if (this.isNoop() || other.isNoop()) {\n        return true;\n      }\n\n      var startA = this._getStartIndex(this),\n          startB = this._getStartIndex(other);\n\n      var simpleA = this._getSimpleOp(this),\n          simpleB = this._getSimpleOp(other);\n\n      if (!simpleA || !simpleB) {\n        return false;\n      }\n\n      if (isInsert(simpleA) && isInsert(simpleB)) {\n        return startA + simpleA.length === startB || startA === startB;\n      }\n\n      if (isDelete(simpleA) && isDelete(simpleB)) {\n        return startB - simpleB === startA;\n      }\n\n      return false;\n    }\n  }]);\n\n  return TextOperation;\n}();\n\n_defineProperty(TextOperation, \"isRetain\", isRetain);\n\n_defineProperty(TextOperation, \"isInsert\", isInsert);\n\n_defineProperty(TextOperation, \"isDelete\", isDelete);\n\n_defineProperty(TextOperation, \"fromJSON\", function (ops) {\n  var o = new TextOperation();\n\n  for (var i = 0, l = ops.length; i < l; i++) {\n    var op = ops[i];\n\n    if (isRetain(op)) {\n      o.retain(op);\n    } else if (isInsert(op)) {\n      o.insert(op);\n    } else if (isDelete(op)) {\n      o['delete'](op);\n    } else {\n      throw new Error(\"unknown operation: \" + JSON.stringify(op));\n    }\n  }\n\n  return o;\n});\n\n_defineProperty(TextOperation, \"transform\", function (operation1, operation2) {\n  if (operation1.baseLength !== operation2.baseLength) {\n    throw new Error(\"Both operations have to have the same base length\");\n  }\n\n  var operation1prime = new TextOperation();\n  var operation2prime = new TextOperation();\n  var ops1 = operation1.ops,\n      ops2 = operation2.ops;\n  var i1 = 0,\n      i2 = 0;\n  var op1 = ops1[i1++],\n      op2 = ops2[i2++];\n\n  while (true) {\n    // At every iteration of the loop, the imaginary cursor that both\n    // operation1 and operation2 have that operates on the input string must\n    // have the same position in the input string.\n    if (typeof op1 === 'undefined' && typeof op2 === 'undefined') {\n      // end condition: both ops1 and ops2 have been processed\n      break;\n    } // next two cases: one or both ops are insert ops\n    // => insert the string in the corresponding prime operation, skip it in\n    // the other one. If both op1 and op2 are insert ops, prefer op1.\n\n\n    if (isInsert(op1)) {\n      operation1prime.insert(op1);\n      operation2prime.retain(op1.length);\n      op1 = ops1[i1++];\n      continue;\n    }\n\n    if (isInsert(op2)) {\n      operation1prime.retain(op2.length);\n      operation2prime.insert(op2);\n      op2 = ops2[i2++];\n      continue;\n    }\n\n    if (typeof op1 === 'undefined') {\n      throw new Error(\"Cannot compose operations: first operation is too short.\");\n    }\n\n    if (typeof op2 === 'undefined') {\n      throw new Error(\"Cannot compose operations: first operation is too long.\");\n    }\n\n    var minl;\n\n    if (isRetain(op1) && isRetain(op2)) {\n      // Simple case: retain/retain\n      if (op1 > op2) {\n        minl = op2;\n        op1 = op1 - op2;\n        op2 = ops2[i2++];\n      } else if (op1 === op2) {\n        minl = op2;\n        op1 = ops1[i1++];\n        op2 = ops2[i2++];\n      } else {\n        minl = op1;\n        op2 = op2 - op1;\n        op1 = ops1[i1++];\n      }\n\n      operation1prime.retain(minl);\n      operation2prime.retain(minl);\n    } else if (isDelete(op1) && isDelete(op2)) {\n      // Both operations delete the same string at the same position. We don't\n      // need to produce any operations, we just skip over the delete ops and\n      // handle the case that one operation deletes more than the other.\n      if (-op1 > -op2) {\n        op1 = op1 - op2;\n        op2 = ops2[i2++];\n      } else if (op1 === op2) {\n        op1 = ops1[i1++];\n        op2 = ops2[i2++];\n      } else {\n        op2 = op2 - op1;\n        op1 = ops1[i1++];\n      } // next two cases: delete/retain and retain/delete\n\n    } else if (isDelete(op1) && isRetain(op2)) {\n      if (-op1 > op2) {\n        minl = op2;\n        op1 = op1 + op2;\n        op2 = ops2[i2++];\n      } else if (-op1 === op2) {\n        minl = op2;\n        op1 = ops1[i1++];\n        op2 = ops2[i2++];\n      } else {\n        minl = -op1;\n        op2 = op2 + op1;\n        op1 = ops1[i1++];\n      }\n\n      operation1prime['delete'](minl);\n    } else if (isRetain(op1) && isDelete(op2)) {\n      if (op1 > -op2) {\n        minl = -op2;\n        op1 = op1 + op2;\n        op2 = ops2[i2++];\n      } else if (op1 === -op2) {\n        minl = op1;\n        op1 = ops1[i1++];\n        op2 = ops2[i2++];\n      } else {\n        minl = op1;\n        op2 = op2 + op1;\n        op1 = ops1[i1++];\n      }\n\n      operation2prime['delete'](minl);\n    } else {\n      throw new Error(\"The two operations aren't compatible\");\n    }\n  }\n\n  return [operation1prime, operation2prime];\n});\n\n\n\n//# sourceURL=webpack://ot_es/./src/common/text-operation.js?");

/***/ }),

/***/ "./src/common/wrapped-operation.js":
/*!*****************************************!*\
  !*** ./src/common/wrapped-operation.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WrappedOperation; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar WrappedOperation =\n/*#__PURE__*/\nfunction () {\n  // A WrappedOperation contains an operation and corresponing metadata.\n  function WrappedOperation(operation, meta) {\n    _classCallCheck(this, WrappedOperation);\n\n    this.wrapped = operation;\n    this.meta = meta;\n  }\n\n  _createClass(WrappedOperation, [{\n    key: \"apply\",\n    value: function apply() {\n      return this.wrapped.apply.apply(this.wrapped, arguments);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      var meta = this.meta;\n      return new WrappedOperation(this.wrapped.invert.apply(this.wrapped, arguments), meta && _typeof(meta) === 'object' && typeof meta.invert === 'function' ? meta.invert.apply(meta, arguments) : meta);\n    }\n  }, {\n    key: \"_copy\",\n    // Copy all properties from source to target.\n    value: function _copy(source, target) {\n      for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n  }, {\n    key: \"_composeMeta\",\n    value: function _composeMeta(a, b) {\n      if (a && _typeof(a) === 'object') {\n        if (typeof a.compose === 'function') {\n          return a.compose(b);\n        }\n\n        var meta = {};\n\n        this._copy(a, meta);\n\n        this._copy(b, meta);\n\n        return meta;\n      }\n\n      return b;\n    }\n  }, {\n    key: \"compose\",\n    value: function compose(other) {\n      return new WrappedOperation(this.wrapped.compose(other.wrapped), this._composeMeta(this.meta, other.meta));\n    }\n  }]);\n\n  return WrappedOperation;\n}();\n\n_defineProperty(WrappedOperation, \"transform\", function (a, b) {\n  var _transformMeta = function _transformMeta(meta, operation) {\n    if (meta && _typeof(meta) === 'object') {\n      if (typeof meta.transform === 'function') {\n        return meta.transform(operation);\n      }\n    }\n\n    return meta;\n  };\n\n  var transform = a.wrapped.constructor.transform;\n  var pair = transform(a.wrapped, b.wrapped);\n  return [new WrappedOperation(pair[0], _transformMeta(a.meta, b.wrapped)), new WrappedOperation(pair[1], _transformMeta(b.meta, a.wrapped))];\n});\n\n\n\n//# sourceURL=webpack://ot_es/./src/common/wrapped-operation.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: TextOperation, SimpleTextOperation, WrappedOperation, Selection, AjaxAdapter, Client, CodeMirrorAdapter, SocketIOAdapter, EditorClient, UndoManager, Server, EditorSocketIOServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var common_text_operation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/text-operation */ \"./src/common/text-operation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TextOperation\", function() { return common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var common_simple_text_operation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/simple-text-operation */ \"./src/common/simple-text-operation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SimpleTextOperation\", function() { return common_simple_text_operation__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var common_wrapped_operation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/wrapped-operation */ \"./src/common/wrapped-operation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WrappedOperation\", function() { return common_wrapped_operation__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var common_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/selection */ \"./src/common/selection.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Selection\", function() { return common_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var browser_ajax_adapter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! browser/ajax-adapter */ \"./src/browser/ajax-adapter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AjaxAdapter\", function() { return browser_ajax_adapter__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var browser_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! browser/client */ \"./src/browser/client.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Client\", function() { return browser_client__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var browser_codemirror_adapter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! browser/codemirror-adapter.js */ \"./src/browser/codemirror-adapter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CodeMirrorAdapter\", function() { return browser_codemirror_adapter_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var browser_socketio_adapter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! browser/socketio-adapter */ \"./src/browser/socketio-adapter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SocketIOAdapter\", function() { return browser_socketio_adapter__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var browser_editor_client__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! browser/editor-client */ \"./src/browser/editor-client.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EditorClient\", function() { return browser_editor_client__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var browser_undo_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! browser/undo-manager */ \"./src/browser/undo-manager.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"UndoManager\", function() { return browser_undo_manager__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var server_server__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! server/server */ \"./src/server/server.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Server\", function() { return server_server__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var server_editor_socketio_server__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! server/editor-socketio-server */ \"./src/server/editor-socketio-server.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EditorSocketIOServer\", function() { return server_editor_socketio_server__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ot_es/./src/index.js?");

/***/ }),

/***/ "./src/server/editor-socketio-server.js":
/*!**********************************************!*\
  !*** ./src/server/editor-socketio-server.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EditorSocketIOServer; });\n/* harmony import */ var common_text_operation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/text-operation */ \"./src/common/text-operation.js\");\n/* harmony import */ var common_wrapped_operation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/wrapped-operation */ \"./src/common/wrapped-operation.js\");\n/* harmony import */ var common_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/selection */ \"./src/common/selection.js\");\n/* harmony import */ var server_server__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! server/server */ \"./src/server/server.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_4__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\nfunction DummyLogger() {\n  return {\n    info: function info() {},\n    error: function error() {},\n    debug: function debug() {}\n  };\n}\n\nvar EditorSocketIOServer =\n/*#__PURE__*/\nfunction (_Server) {\n  _inherits(EditorSocketIOServer, _Server);\n\n  function EditorSocketIOServer(document, operations, docId, mayWrite, operationCallback) {\n    var _this;\n\n    _classCallCheck(this, EditorSocketIOServer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditorSocketIOServer).call(this, document, operations));\n    _this.users = {};\n    _this.docId = docId;\n\n    _this.mayWrite = mayWrite || function (_, cb) {\n      cb(true);\n    };\n\n    _this.operationCallback = operationCallback;\n    _this.isBusy = false;\n    _this.logger = DummyLogger();\n    _this.debug = false;\n    return _this;\n  }\n\n  _createClass(EditorSocketIOServer, [{\n    key: \"setLogger\",\n    value: function setLogger(logger) {\n      this.logger = logger;\n    }\n  }, {\n    key: \"debugLog\",\n    value: function debugLog(msg) {\n      if (this.debug) {\n        this.logger.debug(msg);\n      }\n    }\n  }, {\n    key: \"addClient\",\n    value: function addClient(socket) {\n      var self = this;\n      socket.join(this.docId).emit('doc', {\n        str: this.document,\n        revision: this.operations.length,\n        clients: this.users\n      }).on('operation', function (revision, operation, selection) {\n        self.isBusy = true;\n        socket.origin = 'operation';\n        self.mayWrite(socket, function (mayWrite) {\n          if (!mayWrite) {\n            self.debugLog(\"User doesn't have the right to edit.\");\n            return;\n          }\n\n          try {\n            var ops = self.onOperation(socket, revision, operation, selection);\n\n            if (ops) {\n              self.debugLog(\"new operation: \" + JSON.stringify(ops));\n\n              if (typeof self.operationCallback === 'function') {\n                self.operationCallback(socket, ops, function () {\n                  self.isBusy = false;\n                });\n              } else {\n                self.isBusy = false;\n              }\n            }\n          } catch (err) {\n            self.logger.error(err);\n            setTimeout(function () {\n              socket.emit('doc', {\n                str: self.document,\n                revision: self.operations.length,\n                clients: self.users,\n                force: true\n              });\n            }, 100);\n            self.isBusy = false;\n          }\n        });\n      }).on('get_operations', function (base, head) {\n        self.onGetOperations(socket, base, head);\n      }).on('selection', function (obj) {\n        socket.origin = 'selection';\n        self.mayWrite(socket, function (mayWrite) {\n          if (!mayWrite) {\n            self.debugLog(\"User doesn't have the right to edit.\");\n            return;\n          }\n\n          self.updateSelection(socket, obj && common_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromJSON(obj));\n        });\n      }).on('disconnect', function () {\n        self.debugLog(\"Disconnect\");\n        socket.leave(self.docId);\n        self.onDisconnect(socket);\n      });\n    }\n  }, {\n    key: \"onOperation\",\n    value: function onOperation(socket, revision, operation, selection) {\n      var wrapped;\n\n      try {\n        wrapped = new common_wrapped_operation__WEBPACK_IMPORTED_MODULE_1__[\"default\"](common_text_operation__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromJSON(operation), selection && common_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromJSON(selection));\n      } catch (exc) {\n        this.logger.error(\"Invalid operation received: \");\n        throw new Error(exc);\n      }\n\n      try {\n        var clientId = socket.id;\n        var wrappedPrime = this.receiveOperation(revision, wrapped);\n\n        if (!wrappedPrime) {\n          return;\n        }\n\n        this.getClient(clientId).selection = wrappedPrime.meta;\n        revision = this.operations.length;\n        socket.emit('ack', revision);\n        socket.broadcast.to(this.docId).emit('operation', clientId, revision, wrappedPrime.wrapped.toJSON(), wrappedPrime.meta);\n        return wrappedPrime.wrapped.toJSON();\n      } catch (exc) {\n        throw new Error(exc);\n      }\n    }\n  }, {\n    key: \"onGetOperations\",\n    value: function onGetOperations(socket, base, head) {\n      var operations = this.operations.slice(base, head).map(function (op) {\n        return op.wrapped.toJSON();\n      });\n      socket.emit('operations', head, operations);\n    }\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection(socket, selection) {\n      var clientId = socket.id;\n\n      if (selection) {\n        this.getClient(clientId).selection = selection;\n      } else {\n        delete this.getClient(clientId).selection;\n      }\n\n      socket.broadcast.to(this.docId).emit('selection', clientId, selection);\n    }\n  }, {\n    key: \"setName\",\n    value: function setName(socket, name) {\n      var clientId = socket.id;\n      this.getClient(clientId).name = name;\n      socket.broadcast.to(this.docId).emit('set_name', clientId, name);\n    }\n  }, {\n    key: \"setColor\",\n    value: function setColor(socket, color) {\n      var clientId = socket.id;\n      this.getClient(clientId).color = color;\n      socket.broadcast.to(this.docId).emit('set_color', clientId, color);\n    }\n  }, {\n    key: \"getClient\",\n    value: function getClient(clientId) {\n      return this.users[clientId] || (this.users[clientId] = {});\n    }\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(socket) {\n      var clientId = socket.id;\n      delete this.users[clientId];\n      socket.broadcast.to(this.docId).emit('client_left', clientId);\n    }\n  }]);\n\n  return EditorSocketIOServer;\n}(server_server__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n\n\n\n//# sourceURL=webpack://ot_es/./src/server/editor-socketio-server.js?");

/***/ }),

/***/ "./src/server/server.js":
/*!******************************!*\
  !*** ./src/server/server.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Server; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar Server =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Server, _EventEmitter);\n\n  function Server(document, operations) {\n    var _this;\n\n    _classCallCheck(this, Server);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));\n    _this.document = document;\n    _this.operations = operations || [];\n\n    _this.setDocumentMaxLength(null);\n\n    return _this;\n  }\n\n  _createClass(Server, [{\n    key: \"setDocumentMaxLength\",\n    value: function setDocumentMaxLength(maxLength) {\n      this.documentMaxLength = maxLength;\n    }\n  }, {\n    key: \"receiveOperation\",\n    // Call this method whenever you receive an operation from a client.\n    value: function receiveOperation(revision, operation) {\n      if (revision < 0 || this.operations.length < revision) {\n        throw new Error(\"operation revision not in history\");\n      } // Find all operations that the client didn't know of when it sent the\n      // operation ...\n\n\n      var concurrentOperations = this.operations.slice(revision); // ... and transform the operation against all these operations ...\n\n      var transform = operation.constructor.transform;\n\n      for (var i = 0; i < concurrentOperations.length; i++) {\n        operation = transform(operation, concurrentOperations[i])[0];\n      } // ... and apply that on the document.\n\n\n      var newDocument = operation.apply(this.document); // ignore if exceed the max length of document\n\n      if (typeof this.documentMaxLength === 'number' && newDocument.length > this.documentMaxLength && newDocument.length > this.document.length) {\n        return;\n      }\n\n      this.document = newDocument; // Store operation in history.\n\n      this.operations.push(operation); // It's the caller's responsibility to send the operation to all connected\n      // clients and an acknowledgement to the creator.\n\n      return operation;\n    }\n  }]);\n\n  return Server;\n}(events__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n\n\n//# sourceURL=webpack://ot_es/./src/server/server.js?");

/***/ })

/******/ });